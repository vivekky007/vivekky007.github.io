<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Two-Player Snake</title>
  <style>
    * { box-sizing: border-box; font-family: system-ui,Segoe UI,Roboto,Helvetica,Arial }
    body { display: flex; gap: 20px; padding: 20px; }
    #gameWrap { display: flex; flex-direction: column; gap: 8px; }
    canvas { background: #0b2b1a; border: 4px solid #063; display: block; }
    #ui { display: flex; gap: 8px; align-items: center; }
    input, button { padding: 8px; border-radius: 6px; border: 1px solid #ccc; }
    #log { width: 420px; height: 520px; overflow: auto; background: #111; color: #ddd; padding: 8px; border-radius: 6px; }
    .hint { font-size: 12px; color: #666; }
    #controls { margin-top: 20px; display: flex; flex-direction: column; align-items: center; gap: 10px; }
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="game" width="400" height="400"></canvas>
    <div class="hint">
      Controls: Player A = Arrow keys / Buttons, Player B = WASD.
      Only host runs the game loop. Both players send direction inputs.
    </div>
    <div id="ui">
      <input id="roomIdInput" placeholder="room id (eg. room-123)" />
      <button id="createBtn">Create Room (host)</button>
      <button id="joinBtn">Join Room</button>
      <button id="startBtn">Start Game (host)</button>
    </div>
    <div id="controls">
      <button id="btnUp" style="width:80px;height:50px;font-size:18px">⬆️</button>
      <div style="display:flex; gap:10px;">
        <button id="btnLeft" style="width:80px;height:50px;font-size:18px">⬅️</button>
        <button id="btnRight" style="width:80px;height:50px;font-size:18px">➡️</button>
      </div>
      <button id="btnDown" style="width:80px;height:50px;font-size:18px">⬇️</button>
    </div>
  </div>

  <div id="log">Logs will appear here</div>

<script>
/* ---------------- LOGGING ---------------- */
function log(msg){
  const logBox = document.getElementById('log');
  const ln = document.createElement('div');
  ln.textContent = '['+new Date().toLocaleTimeString()+'] '+msg;
  logBox.appendChild(ln);
  logBox.scrollTop = logBox.scrollHeight;
  console.log(msg);
}

/* ---------------- GAME SETUP ---------------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const cell = 20;
const cols = canvas.width / cell;
const rows = canvas.height / cell;

let gameState = null;    // authoritative state
let playerId = null;     // 'A' or 'B'
let isHost = false;      
let hostInterval = null;

const colors = { A:'#4ce', B:'#e44', apple:'#ff0' };

function resetState(){
  return {
    running:false,
    tick:0,
    snakes:{
      A:{ dir:{x:1,y:0}, body:[{x:2,y:10},{x:1,y:10},{x:0,y:10}] },
      B:{ dir:{x:-1,y:0}, body:[{x:17,y:9},{x:18,y:9},{x:19,y:9}] }
    },
    apple:{ x: Math.floor(cols/2), y: Math.floor(rows/2) }
  };
}

/* ---------------- START GAME ---------------- */
function startGame(asHost=false){
  gameState = resetState();
  isHost = asHost;
  playerId = asHost ? 'A' : (playerId || 'B');
  gameState.running = true;
  log('Game started. You are player '+playerId+(asHost?' (host)':''));
  if(asHost) hostLoop();
}

/* ---------------- HOST LOOP ---------------- */
function hostLoop(){
  if(hostInterval) clearInterval(hostInterval);
  hostInterval = setInterval(()=>{
    tick();
    broadcastState();
  }, 150);
}

function tick(){
  if(!gameState.running) return;
  gameState.tick++;
  for(const pid of ['A','B']){
    const snake = gameState.snakes[pid];
    const head = { x:snake.body[0].x+snake.dir.x, y:snake.body[0].y+snake.dir.y };
    head.x = (head.x+cols)%cols;
    head.y = (head.y+rows)%rows;
    snake.body.unshift(head);
    if(head.x===gameState.apple.x && head.y===gameState.apple.y) placeApple();
    else snake.body.pop();
  }
  if(checkCollision('A') || checkCollision('B')){
    gameState.running=false;
    log('Collision! Game over.');
  }
  render(gameState);
}

function checkCollision(pid){
  const s = gameState.snakes[pid];
  const head = s.body[0];
  for(let i=1;i<s.body.length;i++) if(s.body[i].x===head.x && s.body[i].y===head.y) return true;
  const other = pid==='A'?gameState.snakes['B']:gameState.snakes['A'];
  for(let j=0;j<other.body.length;j++) if(other.body[j].x===head.x && other.body[j].y===head.y) return true;
  return false;
}

function placeApple(){
  let x,y,ok;
  do{
    x=Math.floor(Math.random()*cols);
    y=Math.floor(Math.random()*rows);
    ok=true;
    for(const pid of ['A','B']){
      if(gameState.snakes[pid].body.some(b=>b.x===x&&b.y===y)){ ok=false; break; }
    }
  }while(!ok);
  gameState.apple={x,y};
}

/* ---------------- RENDER ---------------- */
function render(state){
  if(!state) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawCell(state.apple.x,state.apple.y,colors.apple);
  for(const pid of ['A','B']){
    const sn = state.snakes[pid];
    for(let i=0;i<sn.body.length;i++){
      const c = i===0?shade(colors[pid],-20):colors[pid];
      drawCell(sn.body[i].x,sn.body[i].y,c);
    }
  }
}

function drawCell(x,y,color){
  ctx.fillStyle=color;
  ctx.fillRect(x*cell+1,y*cell+1,cell-2,cell-2);
}

function shade(hex,percent){
  const num=parseInt(hex.replace('#',''),16);
  const amt=Math.round(2.55*percent);
  let R=(num>>16)+amt, G=(num>>8&0x00FF)+amt, B=(num&0x0000FF)+amt;
  R=R<255?R<0?0:R:255; G=G<255?G<0?0:G:255; B=B<255?B<0?0:B:255;
  return '#'+(0x1000000+(R<<16)+(G<<8)+B).toString(16).slice(1);
}

/* ---------------- DIRECTION INPUT ---------------- */
function applyDir(pid, dir){
  const snake = gameState.snakes[pid];
  if(snake.dir.x===-dir.x && snake.dir.y===-dir.y) return;
  snake.dir=dir;
}

function sendDir(dir){
  if(isHost){
    applyDir(playerId, dir);
  } else {
    // Non-host: send dir to host
    broadcastDir(playerId, dir);
  }
}

document.getElementById("btnUp").onclick=()=>sendDir({x:0,y:-1});
document.getElementById("btnDown").onclick=()=>sendDir({x:0,y:1});
document.getElementById("btnLeft").onclick=()=>sendDir({x:-1,y:0});
document.getElementById("btnRight").onclick=()=>sendDir({x:1,y:0});

document.addEventListener('keydown', e=>{
  switch(e.key){
    case 'ArrowUp': sendDir({x:0,y:-1}); break;
    case 'ArrowDown': sendDir({x:0,y:1}); break;
    case 'ArrowLeft': sendDir({x:-1,y:0}); break;
    case 'ArrowRight': sendDir({x:1,y:0}); break;
    case 'w': sendDir({x:0,y:-1}); break;
    case 's': sendDir({x:0,y:1}); break;
    case 'a': sendDir({x:-1,y:0}); break;
    case 'd': sendDir({x:1,y:0}); break;
  }
});

/* ---------------- BROADCAST FUNCTIONS ---------------- */
// These would normally be done via your RN signaling server
function broadcastState(){
  // e.g., RN sends state to all players
  // Here just a placeholder:
  console.log('Broadcast state', gameState);
}

function broadcastDir(pid, dir){
  // e.g., RN receives direction and applies to host
  console.log('Broadcast dir from', pid, dir);
}

/* ---------------- UI BUTTONS ---------------- */
document.getElementById('createBtn').onclick=()=>startGame(true);  // host
document.getElementById('startBtn').onclick=()=>startGame(true);   // start game
document.getElementById('joinBtn').onclick=()=>{
  playerId='B';
  log('Joined as Player B. Waiting for host to start.');
};

/* ---------------- INIT ---------------- */
render(resetState());
log('Ready to play. Create or join a room.');

</script>
</body>
</html>
